Roadmap de Desarrollo: Bot de Trading de Skins CS2 con Asistencia de Gemini 2.5 ProEste roadmap está diseñado para guiar el desarrollo del "Sistema Integral y Escalable de Trading de Skins de CS2", utilizando el prompt detallado (id: cs2_trading_bot_github_prompt) como base. Se asume el uso de un entorno de desarrollo asistido por IA como Cursor con Gemini 2.5 Pro.Leyenda de Asistencia de Gemini:(G-Code): Solicitar a Gemini la generación de código base, funciones o clases.(G-Doc): Pedir a Gemini que genere documentación, comentarios o explicaciones.(G-Debug): Utilizar Gemini para ayudar a depurar código o resolver errores.(G-Research): Consultar a Gemini sobre mejores prácticas, alternativas de librerías o detalles de APIs.(G-Refactor): Solicitar a Gemini sugerencias para refactorizar y mejorar la calidad del código.(G-Test): Pedir a Gemini que sugiera casos de prueba o genere esqueletos de pruebas unitarias.Fase 0: Preparación y Configuración del Entorno (Días 1-2)Objetivo: Establecer un entorno de desarrollo sólido y las bases del proyecto.Tarea: Configuración del Entorno de Desarrollo Local.Descripción: Instalar Python (3.9+), crear un entorno virtual (venv), instalar Git.Asistencia Gemini: N/A (tareas manuales).Archivos: N/A.Esfuerzo: Bajo.Tarea: Creación del Repositorio en GitHub y Estructura Inicial del Proyecto.Descripción: Crear un nuevo repositorio en GitHub. Clonarlo localmente. Crear la estructura de directorios básica sugerida en el prompt (config/, core/, utils/, database/, tests/, etc.).Asistencia Gemini: (G-Doc) Solicitar un README.md inicial con la descripción del proyecto y la estructura de directorios.Archivos: Estructura de directorios, README.md, .gitignore inicial.Esfuerzo: Bajo.Prompt Ejemplo para Gemini (G-Doc): "Genera un archivo .gitignore estándar para un proyecto Python, incluyendo exclusiones para entornos virtuales, archivos de configuración sensibles y archivos de base de datos SQLite."Tarea: Configuración Inicial de Herramientas.Descripción: Inicializar requirements.txt. Configurar un linter (ej. Flake8) y un formateador (ej. Black) para mantener la calidad del código.Asistencia Gemini: (G-Research) "Cuáles son los linters y formateadores recomendados para Python y cómo configurarlos?"Archivos: requirements.txt (vacío o con librerías iniciales como requests).Esfuerzo: Bajo.Fase 1: Fundación del Proyecto y Conexión DMarket (Días 3-10, basado en prompt: Días 1-10)Objetivo: Establecer la comunicación con la API de DMarket y la infraestructura básica de logging.Tarea: Implementación del Módulo de Logging (utils/logger.py).Descripción: Configurar un sistema de logging robusto y flexible (logging estructurado, diferentes niveles, salida a consola y archivo).Asistencia Gemini: (G-Code) "Genera un módulo de logging en Python usando la librería logging que permita configurar el nivel de log, formato (incluyendo timestamp, nivel, módulo, mensaje) y salida a consola y un archivo rotativo. Debe ser fácilmente importable y utilizable en otros módulos."Archivos: utils/logger.py.Esfuerzo: Medio.Tarea: Desarrollo del Conector de API de DMarket (core/dmarket_connector.py) - Parte 1 (Autenticación y Endpoints Básicos).Descripción:Implementar la gestión segura de claves API (leer desde variables de entorno o archivo de configuración seguro, NO hardcodear).Crear funciones para autenticación (si es necesaria para los endpoints públicos) y para realizar peticiones GET seguras (HTTPS, validación de certificados).Implementar la función para GET /exchange/v1/market/items con filtros básicos (juego, nombre).Manejo inicial de errores de API (códigos de estado HTTP, excepciones de red).Manejo básico de límites de tasa (retardo simple).Asistencia Gemini:(G-Code) "Escribe una clase Python DMarketAPI en core/dmarket_connector.py que maneje la autenticación (usando una clave API pública y privada leídas de variables de entorno) y una función para hacer peticiones GET al endpoint /exchange/v1/market/items de DMarket. Incluye manejo de errores para códigos de estado HTTP comunes y excepciones de red. Permite pasar parámetros de query para filtrar."(G-Research) "Cuáles son las mejores prácticas para manejar claves API de forma segura en un proyecto Python?"(G-Doc) "Documenta la clase DMarketAPI y sus métodos iniciales."Archivos: core/dmarket_connector.py, archivo .env.example para claves API.Esfuerzo: Alto.Tarea: Script de Prueba Inicial (main.py o script dedicado).Descripción: Crear un script simple que utilice dmarket_connector.py para obtener y mostrar precios de DMarket para una lista predefinida de skins. Usar el logger configurado.Asistencia Gemini: (G-Code) "Escribe un script test_dmarket_fetch.py que importe DMarketAPI de core.dmarket_connector, la inicialice con claves de ejemplo (o placeholders), y llame al método para obtener ítems de CS2, por ejemplo, 'AK-47 | Redline'. Imprime los resultados formateados o algunos campos clave. Utiliza el logger configurado en utils.logger."Archivos: main.py (o script de prueba).Esfuerzo: Medio.Tarea: Pruebas Unitarias Iniciales para dmarket_connector.py.Descripción: Escribir pruebas unitarias usando unittest o pytest para las funciones implementadas en dmarket_connector.py. Usar unittest.mock para simular respuestas de la API.Asistencia Gemini: (G-Test) "Genera un esqueleto de pruebas unitarias con pytest y unittest.mock.patch para la clase DMarketAPI, cubriendo el caso de una respuesta exitosa y un caso de error HTTP (ej. 401 No Autorizado) para el método que llama a /exchange/v1/market/items."Archivos: tests/unit/test_dmarket_connector.py.Esfuerzo: Medio.Fase 2: Scraping SCM, Almacenamiento Básico y Normalización (Días 11-25)Objetivo: Recolectar datos de Steam Community Market, almacenarlos y normalizarlos junto con los de DMarket.Tarea: Desarrollo del Scraper para Steam Community Market (core/market_scrapers.py - Módulo SCM).Descripción:Implementar funciones para buscar un ítem y extraer su precio actual, volumen (si disponible) y precio mediano de la gráfica.Manejar la carga dinámica de contenido de SCM (investigar si requests + análisis XHR es suficiente o si se necesita Selenium/Playwright).Implementar técnicas básicas anti-bloqueo (User-Agent, retardos).Asistencia Gemini:(G-Research) "Cómo extraer datos de precios de Steam Community Market para un ítem específico usando Python? Considerar la carga dinámica y posibles protecciones."(G-Code) "Escribe una función en Python dentro de core/market_scrapers.py llamada get_scm_price(item_name) que use requests y BeautifulSoup4 para obtener el precio más bajo listado para item_name en el Steam Community Market. Incluye manejo básico de errores." (Si se requiere Selenium: "Modifica la función para usar Selenium y obtener el precio...")Archivos: core/market_scrapers.py.Esfuerzo: Alto (SCM puede ser complejo de scrapear).Tarea: Implementación Inicial del Gestor de Datos (core/data_manager.py) con SQLite.Descripción:Definir esquemas SQLAlchemy (o SQL directo) para las tablas: SkinsMaestra (info estática de skins), PreciosHistoricos (precio, timestamp, plataforma), Plataformas.Implementar funciones para inicializar la base de datos y las tablas.Funciones para insertar/actualizar datos de precios de DMarket y SCM.Asistencia Gemini:(G-Code) "Usando SQLAlchemy, define modelos para las tablas SkinsMaestra (con campos como skin_id (PK), market_hash_name (UNIQUE), arma, rareza) y PreciosHistoricos (con precio_id (PK), skin_id (FK), plataforma_id (FK), precio_usd, timestamp). Escribe funciones en core/data_manager.py para crear estas tablas en una base de datos SQLite y para insertar un nuevo registro de precio."(G-Doc) "Explica cómo usar SQLAlchemy para definir modelos y realizar operaciones CRUD básicas."Archivos: core/data_manager.py, database/schema.sql (opcional).Esfuerzo: Alto.Tarea: Funciones de Normalización de Datos.Descripción: Crear funciones en utils/helpers.py o core/data_manager.py para:Normalizar nombres de ítems (ej. asegurar consistencia entre market_hash_name de DMarket y SCM).Convertir todos los precios a USD (si SCM devuelve en moneda local).Estandarizar formatos de fecha/hora.Asistencia Gemini: (G-Code) "Escribe una función Python que tome un nombre de ítem de CS2 y lo normalice a un formato market_hash_name estándar (ej. 'Arma | Skin (Desgaste)'). Considera variaciones comunes."Archivos: utils/helpers.py (o core/data_manager.py).Esfuerzo: Medio.Tarea: Script de Población de Base de Datos.Descripción: Crear un script que use los módulos dmarket_connector, market_scrapers y data_manager para obtener datos de una lista de skins y almacenarlos en la BD SQLite.Asistencia Gemini: (G-Code) "Escribe un script populate_db.py que itere sobre una lista de nombres de skins, obtenga sus precios de DMarket y SCM usando los módulos correspondientes, normalice los datos y los inserte en la base de datos SQLite a través de data_manager."Archivos: populate_db.py (o similar).Esfuerzo: Medio.Fase 3: Estrategia de Arbitraje (DMarket vs SCM), Alertas y Modo Simulación (Semanas 5-8)Objetivo: Implementar la primera estrategia de trading, el sistema de alertas y un modo de simulación.Tarea: Implementación de la Lógica de Arbitraje (core/strategy_engine.py).Descripción:Función para comparar precios de un ítem entre DMarket y SCM desde la BD.Cálculo preciso de comisiones (DMarket ~2-7%, SCM ~15%) y beneficio neto.Lógica para identificar oportunidades viables (beneficio neto > umbral configurable).Asistencia Gemini:(G-Code) "En core/strategy_engine.py, escribe una función find_arbitrage_opportunities_dmarket_scm(db_session, skin_id, config) que consulte los precios más recientes de skin_id en DMarket y SCM desde la base de datos. Debe calcular el beneficio neto de comprar en la plataforma más barata y vender en la más cara, considerando comisiones configurables (ej. DMarket 2%, SCM 15%). Devolver la oportunidad si el ROI supera un umbral en config."(G-Research) "Confirma las estructuras de comisiones actuales para DMarket y Steam Community Market para vendedores."Archivos: core/strategy_engine.py, config/config.ini (para umbrales, comisiones).Esfuerzo: Alto.Tarea: Desarrollo del Módulo de Alertas (core/alerter.py).Descripción: Implementar funciones para enviar notificaciones (inicialmente por email o log destacado, Telegram es una buena adición posterior).Asistencia Gemini: (G-Code) "Escribe una función en core/alerter.py llamada send_email_alert(subject, body, recipient_email, sender_config) que use la librería smtplib para enviar un email. sender_config debe contener los detalles del servidor SMTP y las credenciales." (Para Telegram: "Genera una función similar send_telegram_alert(message, chat_id, bot_token) usando python-telegram-bot.")Archivos: core/alerter.py.Esfuerzo: Medio.Tarea: Creación del Modo Simulación ("Paper Trading").Descripción:Modificar strategy_engine.py y main.py para que, en modo simulación, las "órdenes" se registren en tablas locales (InventarioLocal, Transacciones) sin interactuar con las APIs de compra/venta reales.Simular la ejecución de órdenes basadas en precios de mercado actuales.Asistencia Gemini: (G-Refactor) "Cómo puedo modificar strategy_engine.py para incluir un 'modo simulación'? Cuando se detecta una oportunidad de arbitraje, en lugar de ejecutar una orden real, debería registrar la 'compra' y 'venta' simulada en las tablas InventarioLocal y Transacciones de la base de datos."Archivos: Modificaciones en core/strategy_engine.py, core/data_manager.py (para nuevas tablas/lógica), main.py.Esfuerzo: Alto.Tarea: Pruebas Intensivas de Arbitraje en Modo Simulación.Descripción: Ejecutar el bot en modo simulación con una lista de skins y un capital conceptual ($300-$400). Monitorear alertas, logs y la base de datos para verificar la lógica.Asistencia Gemini: (G-Debug) Ayuda para analizar logs y identificar posibles errores en la lógica de arbitraje o en los cálculos de comisiones durante la simulación.Archivos: Logs, contenido de la BD.Esfuerzo: Medio.Fase 4: Expansión de Scraping (CSFloat, Buff163) y Estrategia de Flipping (Semanas 9-12)Objetivo: Añadir más fuentes de datos y la estrategia de flipping.Tarea: Añadir Scrapers para CSFloat y Buff163 (core/market_scrapers.py).Descripción:CSFloat: Investigar su API pública primero. Si no, desarrollar scraper (puede requerir Selenium/Playwright).Buff163: Afrontar barreras de acceso (VPN/proxies), idioma, conversión CNY a USD (usar API de tipo de cambio fiable).Integrar los nuevos datos en data_manager.py y la lógica de normalización.Asistencia Gemini:(G-Research) "Existe una API pública oficial para CSFloat? Cuáles son los principales desafíos para scrapear Buff163 desde fuera de China?"(G-Code) "Genera esqueletos de funciones get_csfloat_price(item_name) y get_buff163_price(item_name) en core/market_scrapers.py. Incluye placeholders para la lógica de scraping y conversión de moneda para Buff163."Archivos: core/market_scrapers.py, core/data_manager.py, utils/helpers.py (para conversión de moneda).Esfuerzo: Muy Alto (Buff163 es particularmente desafiante).Tarea: Implementación de la Lógica de Flipping (core/strategy_engine.py).Descripción:Funciones para identificar ítems subvaluados basados en precio actual vs. promedio histórico (desde BD).(Avanzado) Lógica para identificar subvaluación por atributos (float bajo, pegatinas) si estos datos se pueden obtener y almacenar.Considerar catalizadores de mercado (esto puede ser más manual o requerir un módulo de "noticias/eventos" futuro).Asistencia Gemini: (G-Code) "En core/strategy_engine.py, escribe una función find_flipping_opportunities(db_session, skin_id, config) que consulte el precio actual y el precio promedio de X días (configurable) para skin_id. Si el precio actual está un Y% (configurable) por debajo del promedio, marcar como oportunidad de flipping. Considerar el float value si está disponible en la BD."Archivos: core/strategy_engine.py, config/config.ini.Esfuerzo: Alto.Tarea: Refinar data_manager.py para Soportar Más Fuentes y Precios Promedio.Descripción: Asegurar que la BD y las funciones de inserción/consulta puedan manejar datos de todas las plataformas. Implementar el cálculo y almacenamiento/consulta eficiente de precios promedio.Asistencia Gemini: (G-Refactor) "Revisa el esquema de PreciosHistoricos y las funciones de consulta en data_manager.py para calcular eficientemente el precio promedio de los últimos N días para un skin en una plataforma específica."Archivos: core/data_manager.py.Esfuerzo: Medio.Tarea: Expandir Modo Simulación para Estrategia de Flipping.Descripción: Integrar la lógica de flipping en el modo simulación, registrando compras y ventas simuladas.Asistencia Gemini: (G-Debug) Ayuda para integrar y probar la lógica de flipping en el entorno de simulación.Archivos: core/strategy_engine.py, main.py.Esfuerzo: Medio.Fase 5: Estrategia de Holding, Gestión de Riesgos Completa y KPIs (Semanas 13-16)Objetivo: Implementar la estrategia de inversión a largo plazo y un sistema robusto de gestión de riesgos y seguimiento de rendimiento.Tarea: Funcionalidad de Estrategia de Holding (core/strategy_engine.py).Descripción:Permitir al usuario definir una lista de skins "objetivo de holding" y sus precios de compra deseados en config.ini.Monitorear precios y alertar cuando se alcancen los precios objetivo.(En modo simulación) Registrar "compras de holding".Asistencia Gemini: (G-Code) "Añade una función a strategy_engine.py llamada check_holding_targets(db_session, config) que lea una lista de skins y precios objetivo de config. Debe consultar los precios actuales y generar una alerta si un precio objetivo de compra es alcanzado."Archivos: core/strategy_engine.py, config/config.ini.Esfuerzo: Medio.Tarea: Implementación Completa del Módulo de Gestión de Riesgos (core/risk_controller.py).Descripción:Implementar las reglas de gestión de capital para $1000 USD (tamaño de posición, diversificación de estrategias, límite de posiciones activas).Integrar estas reglas en strategy_engine.py para que se verifiquen antes de "ejecutar" cualquier operación (real o simulada).Lógica para stop-loss conceptual (alertas) y take-profit.Asistencia Gemini:(G-Code) "Crea una clase RiskController en core/risk_controller.py que se inicialice con el capital total y las reglas de asignación (ej. % máximo por trade, % por estrategia). Debe tener métodos como can_execute_trade(trade_value, strategy_type) que verifiquen si una operación cumple con las reglas."(G-Refactor) "Integra RiskController en strategy_engine.py para que todas las decisiones de trading pasen por una verificación de riesgo antes de proceder."Archivos: core/risk_controller.py, core/strategy_engine.py.Esfuerzo: Alto.Tarea: Desarrollo de Funciones para Cálculo y Registro de KPIs.Descripción: Implementar funciones en data_manager.py o un nuevo módulo analytics.py para calcular los KPIs definidos en el prompt (ROI, P&L, win/loss ratio, etc.) basados en la tabla Transacciones.Asistencia Gemini: (G-Code) "Escribe funciones en Python para calcular los siguientes KPIs a partir de una lista de diccionarios de transacciones (cada diccionario con 'tipo', 'precio_compra', 'precio_venta', 'comision'): ROI total, P&L neto total, número de trades ganadores/perdedores."Archivos: core/data_manager.py (o utils/analytics.py).Esfuerzo: Medio.Tarea: Integración de KPIs en Alertas y Resúmenes.Descripción: Modificar alerter.py para incluir KPIs relevantes en resúmenes diarios/semanales.Asistencia Gemini: (G-Code) "Modifica la función de alerta por email para que pueda aceptar un diccionario de KPIs y formatearlos en el cuerpo del email como un resumen de rendimiento."Archivos: core/alerter.py.Esfuerzo: Bajo.Fase 6: (Opcional) Desarrollo de UI, Optimización y Documentación Final (Continuo, Semanas 17+)Objetivo: Mejorar la usabilidad, el rendimiento y finalizar la documentación.Tarea: Desarrollo de un Dashboard Básico (ej. con Streamlit).Descripción: Crear una interfaz simple para visualizar precios, oportunidades detectadas, estado del bot y KPIs.Asistencia Gemini: (G-Code) "Genera un script básico de Streamlit que se conecte a la base de datos SQLite y muestre una tabla de los últimos 10 precios históricos para un skin seleccionable y un gráfico simple de su tendencia de precios."Archivos: Nuevo directorio dashboard_app/ con archivos de Streamlit.Esfuerzo: Alto (si se busca algo pulido).Tarea: Optimización del Rendimiento.Descripción: Perfilar el código (scrapers, consultas a BD, algoritmos) e identificar cuellos de botella. Optimizar según sea necesario.Asistencia Gemini: (G-Research) "Cuáles son las herramientas y técnicas comunes para perfilar código Python y optimizar consultas SQLAlchemy?" (G-Refactor) "Revisa esta función de scraping/consulta a BD y sugiere optimizaciones."Archivos: Todos los módulos principales.Esfuerzo: Medio-Alto (continuo).Tarea: Pruebas Exhaustivas y Refinamiento.Descripción: Realizar pruebas de larga duración en modo simulación. Refinar umbrales, parámetros de estrategias y reglas de riesgo basadas en los resultados.Asistencia Gemini: N/A (requiere análisis de resultados de simulación).Archivos: config/config.ini, logs.Esfuerzo: Alto (continuo).Tarea: Revisión y Finalización de la Documentación.Descripción: Asegurar que README.md esté completo y actualizado. Añadir docstrings y comentarios donde falten. Crear una guía de uso básica.Asistencia Gemini: (G-Doc) "Revisa y expande el README.md para incluir secciones sobre cómo configurar las estrategias, interpretar los logs y solucionar problemas comunes. Genera docstrings para las funciones principales de strategy_engine.py."Archivos: README.md, todos los archivos .py.Esfuerzo: Medio.Tarea: Considerar "Paper Trading" con Capital Real Limitado.Descripción: Si el modo simulación es consistentemente rentable y el sistema es estable, considerar operar con una pequeña cantidad de capital real bajo supervisión constante.Asistencia Gemini: N/A.Archivos: N/A.Esfuerzo: Alto (requiere precaución extrema).Consideraciones Continuas (Durante todo el proyecto):Pruebas Rigurosas: Escribir pruebas unitarias y de integración continuamente. (G-Test)Refactorización: Mantener el código limpio, legible y bien organizado. (G-Refactor)Seguridad: Revisar periódicamente la gestión de claves API y la seguridad general. (G-Research)Cumplimiento de ToS: Estar siempre al tanto de los Términos de Servicio de las plataformas y ajustar el bot si es necesario. (G-Research)Control de Versiones: Realizar commits frecuentes y descriptivos en Git. Usar ramas para nuevas funcionalidades.Este roadmap proporciona una estructura detallada. La duración de cada fase es una estimación y puede variar según tu experiencia y la complejidad que decidas implementar en cada módulo. ¡Mucha suerte con el desarrollo de tu bot!